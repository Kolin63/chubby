#!/usr/bin/env bash

###############################################################################
#
# HELP
#
###############################################################################

function print_help() {
  echo "usage: chubby [-DnOr] [-p port] [-f file] [src > dest] ..."
}

if [[ "$1" == "-h" ]] || [ "$1" == "--help" ]; then
  print_help
  exit 0
fi

###############################################################################
#
# ARGUMENT PARSING
#
###############################################################################

switch_D=""
switch_n=""
switch_O=""
switch_r=""

port="22"
port_waiting=-1

file=".chubby"
file_waiting=-1

src=""
potential_src=""
dest=""
dest_waiting=-1

# params: single argument, original argument number
function parse_arg() {

  local arg=${1}
  local narg=${2}

  if [ $port_waiting -ne $narg ]; then
    port_waiting=-1
  fi
  if [ $file_waiting -ne $narg ]; then
    file_waiting=-1
  fi
  if [ $dest_waiting -ne $narg ]; then
    dest_waiting=-1
  fi

  if [[ ${arg:0:1} = "-" ]]; then
    for (( chari=1; chari<${#arg}; chari++ )); do

      char=${arg:$chari:1}

      # handle switches
      if   [[ "$char" == "D" ]]; then
        switch_D="-D"
      elif [[ "$char" == "n" ]]; then
        switch_n="-n"
      elif [[ "$char" == "O" ]]; then
        switch_O="-O"
      elif [[ "$char" == "r" ]]; then
        switch_r="-r"

        # handle arguments
      elif [[ "$char" == "p" ]]; then
        port_waiting=$((i+1))
      elif [[ "$char" == "f" ]]; then
        file_waiting=$((i+1))

      fi

    done

  # handle update operator
  elif [[ "$arg" == "=" ]]; then
    dest_waiting=$((i+1))
    src=$potential_src

    # handle argument values
  elif [ $port_waiting -eq $narg ]; then
    port=$arg
  elif [ $file_waiting -eq $narg ]; then
    file=$arg
  elif [ $dest_waiting -eq $narg ]; then
    dest=$arg

  fi

  potential_src=$arg
}

# params: arguments
function parse_args() {
  for (( i=1; i<=$#; i++ )); do
    local arg=${!i}
    parse_arg $arg $i
  done
}

function find_file() {
  local dir=$(pwd)
  while [ ! -e "$dir/$file" ]; do
    dir=$(realpath "$dir/../")
    if [[ "$dir" == "$HOME" ]] || [[ "$dir" == "/" ]]; then
      echo "Could not find file $file"
      print_help
      exit 1
    fi
  done
  echo "Using file: $dir/$file"
  parse_args $(cat "$dir/$file")
}


parse_args $@
if [[ "$switch_n" == "" ]]; then
  find_file
fi

echo "switch_D: $switch_D"
echo "switch_n: $switch_n"
echo "switch_O: $switch_O"
echo "switch_r: $switch_r"
echo "port:     $port"
echo "file:     $file"
echo "src:      $src"
echo "dest:     $dest"

###############################################################################
#
# LOCATION PARSING
#
###############################################################################

src_host=""
src_path=""
src_port=$port

dest_host=""
dest_path=""
dest_port=$port

# param: location (src or dest)
function parse_location() {

  local colons=0
  local backslash=0

  for (( chari=0; chari<${#1}; chari++ )); do

    local char=${1:$chari:1}

    if [[ "$char" == ":" ]] && [ $backslash -eq 0 ]; then
      colons=$(($colons+1))
    fi

    echo "$char $colons"

    if [[ "$char" == "\\" ]] && [ $backslash -eq 0 ]; then
      backslash=1
    else
      backslash=0
    fi

  done
}

parse_location $src
echo
parse_location $dest
